#cloud-config
write_files:
  - path: /etc/systemd/system/control-plane.service
    content: |
      [Unit]
      Description=Envoy Control Plane
      After=network.target

      [Service]
      Type=simple
      User=root
      WorkingDirectory=/opt/control-plane
      ExecStart=/opt/control-plane/control-plane
      Restart=always
      RestartSec=10

      StandardOutput=journal
      StandardError=journal

      [Install]
      WantedBy=multi-user.target

  - path: /opt/control-plane/config.yaml
    content: |
      discovery:
        # app name tag
        # app_name: "backend"

        # name pattern
        # name_pattern: "horizontal-scale-envoyproxy-backend-*"

        # vm names
        vm_names:
          - "auto-discover-vms-app-0"
          - "auto-discover-vms-app-1"

  - path: /opt/control-plane/main.go
    content: |
      package main

      import (
          "context"
          "encoding/json"
          "fmt"
          "log"
          "net"
          "net/http"
          "os"
          "strings"
          "sync"
          "time"

          "gopkg.in/yaml.v3"
          "github.com/Azure/azure-sdk-for-go/sdk/azidentity"
          "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v5"
          "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/network/armnetwork/v5"
          cluster "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3"
          core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
          endpoint "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3"
          listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
          route "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
          router "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/router/v3"
          hcm "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
          clusterservice "github.com/envoyproxy/go-control-plane/envoy/service/cluster/v3"
          discoverygrpc "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
          endpointservice "github.com/envoyproxy/go-control-plane/envoy/service/endpoint/v3"
          listenerservice "github.com/envoyproxy/go-control-plane/envoy/service/listener/v3"
          routeservice "github.com/envoyproxy/go-control-plane/envoy/service/route/v3"
          "github.com/envoyproxy/go-control-plane/pkg/cache/types"
          "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
          "github.com/envoyproxy/go-control-plane/pkg/resource/v3"
          "github.com/envoyproxy/go-control-plane/pkg/server/v3"
          "google.golang.org/grpc"
          "google.golang.org/grpc/keepalive"
          "google.golang.org/protobuf/types/known/anypb"
          "google.golang.org/protobuf/types/known/durationpb"
      )

      const (
          grpcPort        = 18000
          httpPort        = 8080
          subscriptionID  = "${subscription_id}"
          resourceGroup   = "${resource_group_name}"
          pollingInterval = 30 * time.Second
      )

      type Config struct {
          Discovery struct {
              AppName     string   `yaml:"app_name"`
              NamePattern string   `yaml:"name_pattern"`
              VMNames     []string `yaml:"vm_names"`
          } `yaml:"discovery"`
      }

      type VMInfo struct {
          Name      string `json:"name"`
          PublicIP  string `json:"public_ip"`
          PrivateIP string `json:"private_ip"`
      }

      type DiscoveryStatus struct {
          LastUpdate    time.Time `json:"last_update"`
          VMs           []VMInfo  `json:"vms"`
          TotalVMs      int       `json:"total_vms"`
          SnapshotVersion int     `json:"snapshot_version"`
      }

      type AzureDiscovery struct {
          vmClient       *armcompute.VirtualMachinesClient
          nicClient      *armnetwork.InterfacesClient
          publicIPClient *armnetwork.PublicIPAddressesClient
          config         Config
          ctx            context.Context

          // Thread-safe status
          mu     sync.RWMutex
          status DiscoveryStatus
      }

      func loadConfig(path string) (*Config, error) {
          data, err := os.ReadFile(path)
          if err != nil {
              return nil, err
          }

          var config Config
          if err := yaml.Unmarshal(data, &config); err != nil {
              return nil, err
          }

          return &config, nil
      }

      func NewAzureDiscovery(ctx context.Context, config Config) (*AzureDiscovery, error) {
          cred, err := azidentity.NewDefaultAzureCredential(nil)
          if err != nil {
              return nil, fmt.Errorf("failed to get credentials: %v", err)
          }

          vmClient, err := armcompute.NewVirtualMachinesClient(subscriptionID, cred, nil)
          if err != nil {
              return nil, fmt.Errorf("failed to create VM client: %v", err)
          }

          nicClient, err := armnetwork.NewInterfacesClient(subscriptionID, cred, nil)
          if err != nil {
              return nil, fmt.Errorf("failed to create NIC client: %v", err)
          }

          publicIPClient, err := armnetwork.NewPublicIPAddressesClient(subscriptionID, cred, nil)
          if err != nil {
              return nil, fmt.Errorf("failed to create Public IP client: %v", err)
          }

          return &AzureDiscovery{
              vmClient:       vmClient,
              nicClient:      nicClient,
              publicIPClient: publicIPClient,
              config:         config,
              ctx:            ctx,
              status: DiscoveryStatus{
                  VMs: []VMInfo{},
              },
          }, nil
      }

      func (a *AzureDiscovery) GetVMInstances() ([]string, []VMInfo, error) {
          pager := a.vmClient.NewListPager(resourceGroup, nil)

          var ips []string
          var vms []VMInfo

          for pager.More() {
              page, err := pager.NextPage(a.ctx)
              if err != nil {
                  return nil, nil, fmt.Errorf("failed to list VMs: %v", err)
              }

              for _, vm := range page.Value {
                  if !a.matchesCriteria(vm) {
                      continue
                  }

                  publicIP, privateIP, err := a.getIPsFromVM(vm)
                  if err != nil {
                      log.Printf("WARNING: Failed to get IPs for VM %s: %v", *vm.Name, err)
                      continue
                  }

                  log.Printf("INFO: Discovered VM %s with public IP %s (private: %s)", *vm.Name, publicIP, privateIP)

                  ips = append(ips, publicIP)
                  vms = append(vms, VMInfo{
                      Name:      *vm.Name,
                      PublicIP:  publicIP,
                      PrivateIP: privateIP,
                  })
              }
          }

          return ips, vms, nil
      }

      func (a *AzureDiscovery) matchesCriteria(vm *armcompute.VirtualMachine) bool {
          if vm.Name == nil {
              return false
          }

          vmName := *vm.Name

          if len(a.config.Discovery.VMNames) > 0 {
              for _, name := range a.config.Discovery.VMNames {
                  if vmName == name {
                      return true
                  }
              }
              return false
          }

          if a.config.Discovery.NamePattern != "" {
              pattern := strings.TrimSuffix(a.config.Discovery.NamePattern, "*")
              if !strings.HasPrefix(vmName, pattern) {
                  return false
              }
          }

          if a.config.Discovery.AppName != "" {
              if vm.Tags == nil {
                  return false
              }

              appNameTag, exists := vm.Tags["app-name"]
              if !exists || appNameTag == nil || *appNameTag != a.config.Discovery.AppName {
                  return false
              }
          }

          return true
      }

      func (a *AzureDiscovery) getIPsFromVM(vm *armcompute.VirtualMachine) (string, string, error) {
          if vm.Properties == nil || vm.Properties.NetworkProfile == nil {
              return "", "", fmt.Errorf("no network profile")
          }

          nics := vm.Properties.NetworkProfile.NetworkInterfaces
          if len(nics) == 0 {
              return "", "", fmt.Errorf("no network interfaces")
          }

          nicID := *nics[0].ID
          parts := strings.Split(nicID, "/")
          if len(parts) < 9 {
              return "", "", fmt.Errorf("invalid NIC ID format")
          }

          nicRG := parts[4]
          nicName := parts[8]

          nic, err := a.nicClient.Get(a.ctx, nicRG, nicName, nil)
          if err != nil {
              return "", "", fmt.Errorf("failed to get NIC: %v", err)
          }

          if nic.Properties == nil || nic.Properties.IPConfigurations == nil || len(nic.Properties.IPConfigurations) == 0 {
              return "", "", fmt.Errorf("no IP configurations")
          }

          ipConfig := nic.Properties.IPConfigurations[0]

          // Get private IP
          var privateIP string
          if ipConfig.Properties != nil && ipConfig.Properties.PrivateIPAddress != nil {
              privateIP = *ipConfig.Properties.PrivateIPAddress
          }

          // Get public IP
          var publicIP string
          if ipConfig.Properties != nil && ipConfig.Properties.PublicIPAddress != nil {
              publicIPID := *ipConfig.Properties.PublicIPAddress.ID
              publicIPParts := strings.Split(publicIPID, "/")
              if len(publicIPParts) >= 9 {
                  publicIPRG := publicIPParts[4]
                  publicIPName := publicIPParts[8]

                  pubIP, err := a.publicIPClient.Get(a.ctx, publicIPRG, publicIPName, nil)
                  if err == nil && pubIP.Properties != nil && pubIP.Properties.IPAddress != nil {
                      publicIP = *pubIP.Properties.IPAddress
                  }
              }
          }

          if publicIP == "" {
              return "", "", fmt.Errorf("no public IP address found")
          }

          return publicIP, privateIP, nil
      }

      func (a *AzureDiscovery) UpdateStatus(vms []VMInfo, version int) {
          a.mu.Lock()
          defer a.mu.Unlock()

          a.status = DiscoveryStatus{
              LastUpdate:      time.Now(),
              VMs:             vms,
              TotalVMs:        len(vms),
              SnapshotVersion: version,
          }
      }

      func (a *AzureDiscovery) GetStatus() DiscoveryStatus {
          a.mu.RLock()
          defer a.mu.RUnlock()
          return a.status
      }

      // REST API Handlers
      func (a *AzureDiscovery) handleVMs(w http.ResponseWriter, r *http.Request) {
          w.Header().Set("Content-Type", "application/json")
          json.NewEncoder(w).Encode(a.GetStatus())
      }

      func (a *AzureDiscovery) handleHealth(w http.ResponseWriter, r *http.Request) {
          w.Header().Set("Content-Type", "application/json")

          status := a.GetStatus()
          health := map[string]interface{}{
              "status": "healthy",
              "last_update": status.LastUpdate,
              "uptime": time.Since(status.LastUpdate).Seconds(),
              "total_vms": status.TotalVMs,
          }

          json.NewEncoder(w).Encode(health)
      }

      func (a *AzureDiscovery) handleTrigger(w http.ResponseWriter, r *http.Request) {
          if r.Method != http.MethodPost {
              http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
              return
          }

          w.Header().Set("Content-Type", "application/json")

          log.Println("Manual discovery triggered via API")
          json.NewEncoder(w).Encode(map[string]string{
              "message": "Discovery triggered",
              "note": "Check logs for results",
          })
      }

      // Envoy xDS functions
      func makeCluster(clusterName string) *cluster.Cluster {
          return &cluster.Cluster{
              Name:                 clusterName,
              ConnectTimeout:       durationpb.New(5 * time.Second),
              ClusterDiscoveryType: &cluster.Cluster_Type{Type: cluster.Cluster_EDS},
              EdsClusterConfig: &cluster.Cluster_EdsClusterConfig{
                  EdsConfig: &core.ConfigSource{
                      ResourceApiVersion: core.ApiVersion_V3,
                      ConfigSourceSpecifier: &core.ConfigSource_Ads{
                          Ads: &core.AggregatedConfigSource{},
                      },
                  },
              },
          }
      }

      func makeEndpoint(clusterName string, ips []string) *endpoint.ClusterLoadAssignment {
          var endpoints []*endpoint.LbEndpoint

          for _, ip := range ips {
              endpoints = append(endpoints, &endpoint.LbEndpoint{
                  HostIdentifier: &endpoint.LbEndpoint_Endpoint{
                      Endpoint: &endpoint.Endpoint{
                          Address: &core.Address{
                              Address: &core.Address_SocketAddress{
                                  SocketAddress: &core.SocketAddress{
                                      Protocol: core.SocketAddress_TCP,
                                      Address:  ip,
                                      PortSpecifier: &core.SocketAddress_PortValue{
                                          PortValue: 8080,
                                      },
                                  },
                              },
                          },
                      },
                  },
              })
          }

          return &endpoint.ClusterLoadAssignment{
              ClusterName: clusterName,
              Endpoints: []*endpoint.LocalityLbEndpoints{{
                  LbEndpoints: endpoints,
              }},
          }
      }

      func makeRoute(routeName, clusterName string) *route.RouteConfiguration {
          return &route.RouteConfiguration{
              Name: routeName,
              VirtualHosts: []*route.VirtualHost{{
                  Name:    "backend",
                  Domains: []string{"*"},
                  Routes: []*route.Route{{
                      Match: &route.RouteMatch{
                          PathSpecifier: &route.RouteMatch_Prefix{
                              Prefix: "/",
                          },
                      },
                      Action: &route.Route_Route{
                          Route: &route.RouteAction{
                              ClusterSpecifier: &route.RouteAction_Cluster{
                                  Cluster: clusterName,
                              },
                          },
                      },
                  }},
              }},
          }
      }

      func makeHTTPListener(listenerName, routeName string) *listener.Listener {
          routerConfig, _ := anypb.New(&router.Router{})

          manager := &hcm.HttpConnectionManager{
              StatPrefix: "ingress_http",
              RouteSpecifier: &hcm.HttpConnectionManager_Rds{
                  Rds: &hcm.Rds{
                      RouteConfigName: routeName,
                      ConfigSource: &core.ConfigSource{
                          ResourceApiVersion: core.ApiVersion_V3,
                          ConfigSourceSpecifier: &core.ConfigSource_Ads{
                              Ads: &core.AggregatedConfigSource{},
                          },
                      },
                  },
              },
              HttpFilters: []*hcm.HttpFilter{{
                  Name: "envoy.filters.http.router",
                  ConfigType: &hcm.HttpFilter_TypedConfig{
                      TypedConfig: routerConfig,
                  },
              }},
          }

          pbst, _ := anypb.New(manager)

          return &listener.Listener{
              Name: listenerName,
              Address: &core.Address{
                  Address: &core.Address_SocketAddress{
                      SocketAddress: &core.SocketAddress{
                          Protocol: core.SocketAddress_TCP,
                          Address:  "0.0.0.0",
                          PortSpecifier: &core.SocketAddress_PortValue{
                              PortValue: 8080,
                          },
                      },
                  },
              },
              FilterChains: []*listener.FilterChain{{
                  Filters: []*listener.Filter{{
                      Name: "envoy.filters.network.http_connection_manager",
                      ConfigType: &listener.Filter_TypedConfig{
                          TypedConfig: pbst,
                      },
                  }},
              }},
          }
      }

      func generateSnapshot(version string, ips []string) (*cache.Snapshot, error) {
          return cache.NewSnapshot(
              version,
              map[resource.Type][]types.Resource{
                  resource.ClusterType:  {makeCluster("backend_cluster")},
                  resource.RouteType:    {makeRoute("local_route", "backend_cluster")},
                  resource.ListenerType: {makeHTTPListener("listener_0", "local_route")},
                  resource.EndpointType: {makeEndpoint("backend_cluster", ips)},
              },
          )
      }

      func main() {
          ctx := context.Background()

          log.Println("Loading configuration...")
          config, err := loadConfig("/opt/control-plane/config.yaml")
          if err != nil {
              log.Fatalf("Failed to load config: %v", err)
          }

          log.Printf("Discovery config: AppName=%s, NamePattern=%s, VMNames=%v",
              config.Discovery.AppName,
              config.Discovery.NamePattern,
              config.Discovery.VMNames,
          )

          log.Println("Starting Envoy control plane with REST API...")

          discovery, err := NewAzureDiscovery(ctx, *config)
          if err != nil {
              log.Fatalf("Failed to create Azure discovery: %v", err)
          }

          snapshotCache := cache.NewSnapshotCache(false, cache.IDHash{}, nil)
          srv := server.NewServer(ctx, snapshotCache, nil)

          // Start discovery loop
          go func() {
              version := 1
              for {
                  log.Printf("Polling Azure for VMs (attempt %d)...", version)

                  ips, vms, err := discovery.GetVMInstances()
                  if err != nil {
                      log.Printf("ERROR: Failed to get VM instances: %v", err)
                      time.Sleep(pollingInterval)
                      continue
                  }

                  if len(ips) == 0 {
                      log.Printf("WARNING: No instances discovered")
                  } else {
                      log.Printf("SUCCESS: Discovered %d instances with public IPs: %v", len(ips), ips)
                  }

                  // Update internal status for API
                  discovery.UpdateStatus(vms, version)

                  snapshot, err := generateSnapshot(fmt.Sprintf("%d", version), ips)
                  if err != nil {
                      log.Printf("ERROR: Failed to generate snapshot: %v", err)
                      time.Sleep(pollingInterval)
                      continue
                  }

                  if err := snapshotCache.SetSnapshot(ctx, "envoy-node-1", snapshot); err != nil {
                      log.Printf("ERROR: Failed to set snapshot: %v", err)
                  } else {
                      log.Printf("SUCCESS: Updated snapshot to version %d", version)
                  }

                  version++
                  time.Sleep(pollingInterval)
              }
          }()

          // Start REST API server
          go func() {
              mux := http.NewServeMux()
              mux.HandleFunc("/api/vms", discovery.handleVMs)
              mux.HandleFunc("/api/health", discovery.handleHealth)
              mux.HandleFunc("/api/discovery/trigger", discovery.handleTrigger)

              log.Printf("REST API listening on :%d", httpPort)
              log.Printf("  GET  /api/vms - List discovered VMs")
              log.Printf("  GET  /api/health - Health check")
              log.Printf("  POST /api/discovery/trigger - Trigger manual discovery")

              if err := http.ListenAndServe(fmt.Sprintf(":%d", httpPort), mux); err != nil {
                  log.Fatalf("Failed to start REST API: %v", err)
              }
          }()

          // Start gRPC xDS server
          grpcServer := grpc.NewServer(
              grpc.KeepaliveParams(keepalive.ServerParameters{
                  Time:    30 * time.Second,
                  Timeout: 5 * time.Second,
              }),
          )

          discoverygrpc.RegisterAggregatedDiscoveryServiceServer(grpcServer, srv)
          endpointservice.RegisterEndpointDiscoveryServiceServer(grpcServer, srv)
          clusterservice.RegisterClusterDiscoveryServiceServer(grpcServer, srv)
          routeservice.RegisterRouteDiscoveryServiceServer(grpcServer, srv)
          listenerservice.RegisterListenerDiscoveryServiceServer(grpcServer, srv)

          lis, err := net.Listen("tcp", fmt.Sprintf(":%d", grpcPort))
          if err != nil {
              log.Fatalf("Failed to listen on port %d: %v", grpcPort, err)
          }

          log.Printf("xDS gRPC server listening on :%d", grpcPort)
          if err := grpcServer.Serve(lis); err != nil {
              log.Fatalf("Failed to serve: %v", err)
          }
      }

  - path: /opt/control-plane/go.mod
    content: |
      module control-plane

      go 1.21

      require (
          github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.5.1
          github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v5 v5.4.0
          github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/network/armnetwork/v5 v5.1.1
          github.com/envoyproxy/go-control-plane v0.12.0
          google.golang.org/grpc v1.60.1
          google.golang.org/protobuf v1.32.0
          gopkg.in/yaml.v3 v3.0.1
      )

runcmd:
  - |
    set -e
    apt-get update
    apt-get install -y curl
    curl -fsSL https://go.dev/dl/go1.21.5.linux-amd64.tar.gz | tar -C /usr/local -xz

    export HOME=/root
    export GOPATH=/root/go
    export PATH=/usr/local/go/bin:$PATH

    cd /opt/control-plane
    go mod tidy
    go build -o control-plane main.go

    systemctl daemon-reload
    systemctl enable --now control-plane

    echo "Control plane deployment completed"
