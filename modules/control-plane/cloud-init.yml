#cloud-config
write_files:
  - path: /etc/systemd/system/control-plane.service
    content: |
      [Unit]
      Description=Envoy Control Plane
      After=network.target

      [Service]
      Type=simple
      User=root
      WorkingDirectory=/opt/control-plane
      ExecStart=/opt/control-plane/control-plane
      Restart=always
      RestartSec=10

      StandardOutput=journal
      StandardError=journal

      [Install]
      WantedBy=multi-user.target

  - path: /opt/control-plane/config.yaml
    content: |
      discovery:
        # Discover VMs by app-name tag
        # app_name: "backend"

        # Alternative 1
        # name_pattern: "horizontal-scale-envoyproxy-backend-*"

        # Alternative 2
        vm_names:
          - "auto-discover-vms-app-0"
          - "auto-discover-vms-app-1"

  - path: /opt/control-plane/main.go
    content: |
      package main

      import (
          "context"
          "fmt"
          "log"
          "net"
          "os"
          "strings"
          "time"

          "gopkg.in/yaml.v3"
          "github.com/Azure/azure-sdk-for-go/sdk/azidentity"
          "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v5"
          "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/network/armnetwork/v5"
          cluster "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3"
          core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
          endpoint "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3"
          listener "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
          route "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
          router "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/router/v3"
          hcm "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
          clusterservice "github.com/envoyproxy/go-control-plane/envoy/service/cluster/v3"
          discoverygrpc "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
          endpointservice "github.com/envoyproxy/go-control-plane/envoy/service/endpoint/v3"
          listenerservice "github.com/envoyproxy/go-control-plane/envoy/service/listener/v3"
          routeservice "github.com/envoyproxy/go-control-plane/envoy/service/route/v3"
          "github.com/envoyproxy/go-control-plane/pkg/cache/types"
          "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
          "github.com/envoyproxy/go-control-plane/pkg/resource/v3"
          "github.com/envoyproxy/go-control-plane/pkg/server/v3"
          "google.golang.org/grpc"
          "google.golang.org/grpc/keepalive"
          "google.golang.org/protobuf/types/known/anypb"
          "google.golang.org/protobuf/types/known/durationpb"
      )

      const (
          grpcPort        = 18000
          subscriptionID  = "${subscription_id}"
          resourceGroup   = "${resource_group_name}"
          pollingInterval = 30 * time.Second
      )

      type Config struct {
          Discovery struct {
              AppName     string   `yaml:"app_name"`
              NamePattern string   `yaml:"name_pattern"`
              VMNames     []string `yaml:"vm_names"`
          } `yaml:"discovery"`
      }

      type AzureDiscovery struct {
          vmClient  *armcompute.VirtualMachinesClient
          nicClient *armnetwork.InterfacesClient
          publicIPClient *armnetwork.PublicIPAddressesClient
          config    Config
          ctx       context.Context
      }

      func loadConfig(path string) (*Config, error) {
          data, err := os.ReadFile(path)
          if err != nil {
              return nil, err
          }

          var config Config
          if err := yaml.Unmarshal(data, &config); err != nil {
              return nil, err
          }

          return &config, nil
      }

      func NewAzureDiscovery(ctx context.Context, config Config) (*AzureDiscovery, error) {
          cred, err := azidentity.NewDefaultAzureCredential(nil)
          if err != nil {
              return nil, fmt.Errorf("failed to get credentials: %v", err)
          }

          vmClient, err := armcompute.NewVirtualMachinesClient(subscriptionID, cred, nil)
          if err != nil {
              return nil, fmt.Errorf("failed to create VM client: %v", err)
          }

          nicClient, err := armnetwork.NewInterfacesClient(subscriptionID, cred, nil)
          if err != nil {
              return nil, fmt.Errorf("failed to create NIC client: %v", err)
          }

          publicIPClient, err := armnetwork.NewPublicIPAddressesClient(subscriptionID, cred, nil)
          if err != nil {
              return nil, fmt.Errorf("failed to create Public IP client: %v", err)
          }

          return &AzureDiscovery{
              vmClient:  vmClient,
              nicClient: nicClient,
              publicIPClient: publicIPClient,
              config:    config,
              ctx:       ctx,
          }, nil
      }

      func (a *AzureDiscovery) GetVMInstances() ([]string, error) {
          pager := a.vmClient.NewListPager(resourceGroup, nil)

          var ips []string

          for pager.More() {
              page, err := pager.NextPage(a.ctx)
              if err != nil {
                  return nil, fmt.Errorf("failed to list VMs: %v", err)
              }

              for _, vm := range page.Value {
                  if !a.matchesCriteria(vm) {
                      continue
                  }

                  ip, err := a.getPrivateIPFromVM(vm)
                  if err != nil {
                      log.Printf("WARNING: Failed to get IP for VM %s: %v", *vm.Name, err)
                      continue
                  }

                  log.Printf("INFO: Discovered VM %s with IP %s", *vm.Name, ip)
                  ips = append(ips, ip)
              }
          }

          return ips, nil
      }

      func (a *AzureDiscovery) matchesCriteria(vm *armcompute.VirtualMachine) bool {
          if vm.Name == nil {
              return false
          }

          vmName := *vm.Name

          // Option 1: Filter by exact VM names
          if len(a.config.Discovery.VMNames) > 0 {
              for _, name := range a.config.Discovery.VMNames {
                  if vmName == name {
                      return true
                  }
              }
              return false
          }

          // Option 2: Filter by name pattern
          if a.config.Discovery.NamePattern != "" {
              pattern := strings.TrimSuffix(a.config.Discovery.NamePattern, "*")
              if !strings.HasPrefix(vmName, pattern) {
                  return false
              }
          }

          // Option 3: Filter by app-name tag (default)
          if a.config.Discovery.AppName != "" {
              if vm.Tags == nil {
                  return false
              }

              appNameTag, exists := vm.Tags["app-name"]
              if !exists || appNameTag == nil || *appNameTag != a.config.Discovery.AppName {
                  return false
              }
          }

          return true
      }

      func (a *AzureDiscovery) getPrivateIPFromVM(vm *armcompute.VirtualMachine) (string, error) {
          if vm.Properties == nil || vm.Properties.NetworkProfile == nil {
              return "", fmt.Errorf("no network profile")
          }

          nics := vm.Properties.NetworkProfile.NetworkInterfaces
          if len(nics) == 0 {
              return "", fmt.Errorf("no network interfaces")
          }

          nicID := *nics[0].ID
          parts := strings.Split(nicID, "/")
          if len(parts) < 9 {
              return "", fmt.Errorf("invalid NIC ID format")
          }

          nicRG := parts[4]
          nicName := parts[8]

          nic, err := a.nicClient.Get(a.ctx, nicRG, nicName, nil)
          if err != nil {
              return "", fmt.Errorf("failed to get NIC: %v", err)
          }

          if nic.Properties == nil || nic.Properties.IPConfigurations == nil || len(nic.Properties.IPConfigurations) == 0 {
              return "", fmt.Errorf("no IP configurations")
          }

          ipConfig := nic.Properties.IPConfigurations[0]
          if ipConfig.Properties == nil || ipConfig.Properties.PrivateIPAddress == nil {
              return "", fmt.Errorf("no private IP address")
          }

          return *ipConfig.Properties.PrivateIPAddress, nil
      }

      func makeCluster(clusterName string) *cluster.Cluster {
          return &cluster.Cluster{
              Name:                 clusterName,
              ConnectTimeout:       durationpb.New(5 * time.Second),
              ClusterDiscoveryType: &cluster.Cluster_Type{Type: cluster.Cluster_EDS},
              EdsClusterConfig: &cluster.Cluster_EdsClusterConfig{
                  EdsConfig: &core.ConfigSource{
                      ResourceApiVersion: core.ApiVersion_V3,
                      ConfigSourceSpecifier: &core.ConfigSource_Ads{
                          Ads: &core.AggregatedConfigSource{},
                      },
                  },
              },
          }
      }

      func makeEndpoint(clusterName string, ips []string) *endpoint.ClusterLoadAssignment {
          var endpoints []*endpoint.LbEndpoint

          for _, ip := range ips {
              endpoints = append(endpoints, &endpoint.LbEndpoint{
                  HostIdentifier: &endpoint.LbEndpoint_Endpoint{
                      Endpoint: &endpoint.Endpoint{
                          Address: &core.Address{
                              Address: &core.Address_SocketAddress{
                                  SocketAddress: &core.SocketAddress{
                                      Protocol: core.SocketAddress_TCP,
                                      Address:  ip,
                                      PortSpecifier: &core.SocketAddress_PortValue{
                                          PortValue: 8080,
                                      },
                                  },
                              },
                          },
                      },
                  },
              })
          }

          return &endpoint.ClusterLoadAssignment{
              ClusterName: clusterName,
              Endpoints: []*endpoint.LocalityLbEndpoints{{
                  LbEndpoints: endpoints,
              }},
          }
      }

      func makeRoute(routeName, clusterName string) *route.RouteConfiguration {
          return &route.RouteConfiguration{
              Name: routeName,
              VirtualHosts: []*route.VirtualHost{{
                  Name:    "backend",
                  Domains: []string{"*"},
                  Routes: []*route.Route{{
                      Match: &route.RouteMatch{
                          PathSpecifier: &route.RouteMatch_Prefix{
                              Prefix: "/",
                          },
                      },
                      Action: &route.Route_Route{
                          Route: &route.RouteAction{
                              ClusterSpecifier: &route.RouteAction_Cluster{
                                  Cluster: clusterName,
                              },
                          },
                      },
                  }},
              }},
          }
      }

      func makeHTTPListener(listenerName, routeName string) *listener.Listener {
          routerConfig, _ := anypb.New(&router.Router{})

          manager := &hcm.HttpConnectionManager{
              StatPrefix: "ingress_http",
              RouteSpecifier: &hcm.HttpConnectionManager_Rds{
                  Rds: &hcm.Rds{
                      RouteConfigName: routeName,
                      ConfigSource: &core.ConfigSource{
                          ResourceApiVersion: core.ApiVersion_V3,
                          ConfigSourceSpecifier: &core.ConfigSource_Ads{
                              Ads: &core.AggregatedConfigSource{},
                          },
                      },
                  },
              },
              HttpFilters: []*hcm.HttpFilter{{
                  Name: "envoy.filters.http.router",
                  ConfigType: &hcm.HttpFilter_TypedConfig{
                      TypedConfig: routerConfig,
                  },
              }},
          }

          pbst, _ := anypb.New(manager)

          return &listener.Listener{
              Name: listenerName,
              Address: &core.Address{
                  Address: &core.Address_SocketAddress{
                      SocketAddress: &core.SocketAddress{
                          Protocol: core.SocketAddress_TCP,
                          Address:  "0.0.0.0",
                          PortSpecifier: &core.SocketAddress_PortValue{
                              PortValue: 8080,
                          },
                      },
                  },
              },
              FilterChains: []*listener.FilterChain{{
                  Filters: []*listener.Filter{{
                      Name: "envoy.filters.network.http_connection_manager",
                      ConfigType: &listener.Filter_TypedConfig{
                          TypedConfig: pbst,
                      },
                  }},
              }},
          }
      }

      func generateSnapshot(version string, ips []string) (*cache.Snapshot, error) {
          return cache.NewSnapshot(
              version,
              map[resource.Type][]types.Resource{
                  resource.ClusterType:  {makeCluster("backend_cluster")},
                  resource.RouteType:    {makeRoute("local_route", "backend_cluster")},
                  resource.ListenerType: {makeHTTPListener("listener_0", "local_route")},
                  resource.EndpointType: {makeEndpoint("backend_cluster", ips)},
              },
          )
      }

      func main() {
          ctx := context.Background()

          log.Println("Loading configuration...")
          config, err := loadConfig("/opt/control-plane/config.yaml")
          if err != nil {
              log.Fatalf("Failed to load config: %v", err)
          }

          log.Printf("Discovery config: AppName=%s, NamePattern=%s, VMNames=%v",
              config.Discovery.AppName,
              config.Discovery.NamePattern,
              config.Discovery.VMNames,
          )

          log.Println("Starting Envoy control plane...")

          discovery, err := NewAzureDiscovery(ctx, *config)
          if err != nil {
              log.Fatalf("Failed to create Azure discovery: %v", err)
          }

          snapshotCache := cache.NewSnapshotCache(false, cache.IDHash{}, nil)
          srv := server.NewServer(ctx, snapshotCache, nil)

          go func() {
              version := 1
              for {
                  log.Printf("Polling Azure for VMs (attempt %d)...", version)

                  ips, err := discovery.GetVMInstances()
                  if err != nil {
                      log.Printf("ERROR: Failed to get VM instances: %v", err)
                      time.Sleep(pollingInterval)
                      continue
                  }

                  if len(ips) == 0 {
                      log.Printf("WARNING: No instances discovered")
                  } else {
                      log.Printf("SUCCESS: Discovered %d instances: %v", len(ips), ips)
                  }

                  snapshot, err := generateSnapshot(fmt.Sprintf("%d", version), ips)
                  if err != nil {
                      log.Printf("ERROR: Failed to generate snapshot: %v", err)
                      time.Sleep(pollingInterval)
                      continue
                  }

                  if err := snapshotCache.SetSnapshot(ctx, "envoy-node-1", snapshot); err != nil {
                      log.Printf("ERROR: Failed to set snapshot: %v", err)
                  } else {
                      log.Printf("SUCCESS: Updated snapshot to version %d", version)
                  }

                  version++
                  time.Sleep(pollingInterval)
              }
          }()

          grpcServer := grpc.NewServer(
              grpc.KeepaliveParams(keepalive.ServerParameters{
                  Time:    30 * time.Second,
                  Timeout: 5 * time.Second,
              }),
          )

          discoverygrpc.RegisterAggregatedDiscoveryServiceServer(grpcServer, srv)
          endpointservice.RegisterEndpointDiscoveryServiceServer(grpcServer, srv)
          clusterservice.RegisterClusterDiscoveryServiceServer(grpcServer, srv)
          routeservice.RegisterRouteDiscoveryServiceServer(grpcServer, srv)
          listenerservice.RegisterListenerDiscoveryServiceServer(grpcServer, srv)

          lis, err := net.Listen("tcp", fmt.Sprintf(":%d", grpcPort))
          if err != nil {
              log.Fatalf("Failed to listen on port %d: %v", grpcPort, err)
          }

          log.Printf("Control plane listening on :%d", grpcPort)
          if err := grpcServer.Serve(lis); err != nil {
              log.Fatalf("Failed to serve: %v", err)
          }
      }

  - path: /opt/control-plane/go.mod
    content: |
      module control-plane

      go 1.21

      require (
          github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.5.1
          github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v5 v5.4.0
          github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/network/armnetwork/v5 v5.1.1
          github.com/envoyproxy/go-control-plane v0.12.0
          google.golang.org/grpc v1.60.1
          google.golang.org/protobuf v1.32.0
          gopkg.in/yaml.v3 v3.0.1
      )

runcmd:
  - |
    set -e
    apt-get update
    apt-get install -y curl
    curl -fsSL https://go.dev/dl/go1.21.5.linux-amd64.tar.gz | tar -C /usr/local -xz

    export HOME=/root
    export GOPATH=/root/go
    export PATH=/usr/local/go/bin:$PATH

    cd /opt/control-plane
    go mod tidy
    go build -o control-plane main.go

    systemctl daemon-reload
    systemctl enable --now control-plane

    echo "Control plane deployment completed"
